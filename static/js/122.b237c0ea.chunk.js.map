{"version":3,"file":"static/js/122.b237c0ea.chunk.js","mappings":"iIACA,WACIA,WAAY,CAAG,EACfC,KAAM,CAAC,EACPC,OAAQ,22K","sources":["pages/develop/mock/README.md"],"sourcesContent":["\nexport default {\n    components: {  },\n    data: {},\n    source: \"# Mock\\nantdp 提供了开箱即用的 Mock 功能，能够用方便简单的方式来完成 Mock 数据的设置。\\n\\n<strong>\\n什么是 Mock 数据：在前后端约定好 API 接口以后，前端可以使用 Mock 数据来在本地模拟出 API 应该要返回的数据，这样一来前后端开发就可以同时进行，不会因为后端 API\\n还在开发而导致前端的工作被阻塞。\\n</strong>\\n\\n## 目录约定\\nUmi 约定 /mock 目录下的所有文件为 Mock 文件，例如这样的目录结构：\\n\\n```text\\n.\\n├── mock\\n    ├── todos.ts\\n    ├── items.ts\\n    └── users.ts\\n└── src\\n    └── pages\\n        └── index.tsx\\n```\\n\\n则 /mock 目录中的 todos.ts, items.ts 和 users.ts 就会被 Umi 视为 Mock 文件 来处理。\\n\\n## Mock 文件\\nMock 文件默认导出一个对象，而对象的每个 Key 对应了一个 Mock 接口，值则是这个接口所对应的返回数据，例如这样的 Mock 文件：\\n```ts\\n// ./mock/users.ts\\n \\nexport default {\\n \\n  // 返回值可以是数组形式\\n  'GET /api/users': [\\n    { id: 1, name: 'foo' },\\n    { id: 2, name: 'bar' }\\n  ],\\n \\n  // 返回值也可以是对象形式\\n  'GET /api/users/1': { id: 1, name: 'foo' },\\n \\n}\\n```\\n就声明了两个 Mock 接口，透过 GET /api/users 可以拿到一个带有两个用户数据的数组，透过 GET /api/users/1 可以拿到某个用户的模拟数据。\\n\\n## 请求方法\\n当 Http 的请求方法是 GET 时，可以省略方法部分，只需要路径即可，例如：\\n\\n```ts\\n// ./mock/users.ts\\n \\nexport default {\\n \\n  '/api/users': [\\n    { id: 1, name: 'foo' },\\n    { id: 2, name: 'bar' }\\n  ],\\n \\n  '/api/users/1': { id: 1, name: 'foo' },\\n \\n}\\n```\\n\\n也可以用不同的请求方法，例如 POST:\\n```ts\\n// ./mock/users.ts\\n \\nexport default {\\n \\n  'POST /api/users': { result: 'true' },\\n \\n  'PUT /api/users/1': { id: 1, name: 'new-foo' },\\n \\n}\\n```\\n\\n## 自定义函数\\n除了直接静态声明返回值，也可以用函数的方式来声明如何计算返回值，例如：\\n```ts\\nexport default {\\n \\n  'POST /api/users/create': (req, res) => {\\n    // 添加跨域请求头\\n    res.setHeader('Access-Control-Allow-Origin', '*');\\n    res.end('ok');\\n  }\\n \\n}\\n```\\n\\n关于 `req` 和 `res` 的 API 可参考 [Express@4](https://moexpressjs.com/en/api.html) 官方文档 来进一步了解。\\n\\n## defineMock\\n另外，也可以使用 defineMock 类型帮助函数来提供编写 mock 对象的代码提示，如：\\n```ts\\nimport { defineMock } from \\\"@umijs/max\\\";\\n \\nexport default defineMock({\\n  \\\"/api/users\\\": [\\n    { id: 1, name: \\\"foo\\\" },\\n    { id: 2, name: \\\"bar\\\" },\\n  ],\\n  \\\"/api/users/1\\\": { id: 1, name: \\\"foo\\\" },\\n  \\\"GET /api/users/2\\\": (req, res) => {\\n    res.status(200).json({ id: 2, name: \\\"bar\\\" });\\n  },\\n});\\n```\\n\\n`defineMock` 仅仅提供类型提示，入参与出参完全一致。\\n\\n## 关闭 Mock\\n\\nantdp 默认开启 Mock 功能，如果不需要的话可以从配置文件关闭：\\n```ts\\n// config/config.ts\\nimport config from '@antdp/config';\\nimport proxy from './proxy';\\nimport router from './router.json';\\nexport default config(router, {\\n  mock: false,\\n});\\n```\\n\\n或是用环境变量的方式关闭：\\n\\n```bash\\nMOCK=none max dev\\n```\\n\\n## 引入 Mock.js\\n在 Mock 中我们经常使用 [Mock.js](http://mockjs.com/) 来帮我们方便的生成随机的模拟数据，如果你使用了 Umi 的 Mock 功能，建议你搭配这个库来提升模拟数据的真实性：\\n```ts\\nimport mockjs from 'mockjs';\\n \\nexport default {\\n  // 使用 mockjs 等三方库\\n  'GET /api/tags': mockjs.mock({\\n    'list|100': [{ name: '@city', 'value|1-100': 50, 'type|0-2': 1 }],\\n  }),\\n};\\n```\\n\\n## License\\n\\nLicensed under the MIT License.\"\n  }"],"names":["components","data","source"],"sourceRoot":""}