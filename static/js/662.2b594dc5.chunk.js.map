{"version":3,"file":"static/js/662.2b594dc5.chunk.js","mappings":"iIACA,WACIA,WAAY,CAAG,EACfC,KAAM,CAAC,EACPC,OAAQ,g8P","sources":["pages/develop/data-flow/README.md"],"sourcesContent":["\nexport default {\n    components: {  },\n    data: {},\n    source: \"# 数据流\\n@umijs/max 内置了数据流管理插件，它是一种基于 hooks 范式的轻量级数据管理方案，可以在 antdp 项目中管理全局的共享数据。\\n\\n```ts\\n// config/config.ts\\nimport config from '@antdp/config';\\nimport proxy from './proxy';\\nimport router from './router.json';\\nexport default config(router, {\\n  proxy,\\n  define: {\\n  model: {},\\n});\\n```\\n## 开始使用\\n\\n### 创建 Model\\n\\n数据流管理插件采用约定式目录结构，我们约定可以在 `src/models`, `src/pages/xxxx/models/`目录中，和 `src/pages/xxxx/model.{js,jsx,ts,tsx}` 文件引入 Model 文件。 Model 文件允许使用 `.(tsx|ts|jsx|js)` 四种后缀格式，命名空间（namespace） 生成规则如下。\\n\\n| 路径 | 命名空间 | 说明 |\\n| :--- |:--- | :--- |\\n| `src/models/count.ts` | `count` | `src/models` 目录下不支持目录嵌套定义 model |\\n| `src/pages/pageA/model.ts` | `pageA.model` |  |\\n| `src/pages/pageB/models/product.ts` | `pageB.product` |  |\\n| `src/pages/pageB/models/fruit/apple.ts` | `pageB.fruit.apple` |  `pages/xxx/models` 下 model 定义支持嵌套定义 |\\n\\n所谓的 Model，就是一个自定义的 `hooks`，没有任何使用者需要关注的“黑魔法”。\\n\\n当我们需要获取 Model 中的全局数据时，调用该命名空间即可。例如，对于 Model 文件 `userModel.ts`，它的命名空间为 `userModel`。\\n\\n编写一个默认导出的函数：\\n\\n```ts\\n// src/models/userModel.ts\\nexport default function Page() {\\n  const user = {\\n    username: 'umi',\\n  };\\n\\n  return { user };\\n};\\n```\\n\\n这就是一个 Model。插件所做的工作就是将其中的状态或数据变成了**全局数据**，不同的组件在使用该 Model 时，拿到的是同一份状态或数据。\\n\\n<strong>\\nModel 文件需要默认导出一个函数，此函数定义了一个 `hook`。对于不符合此规范的文件，将会被过滤掉，并无法通过命名空间调用。\\n</strong>\\n\\nModel 中允许使用其它 `hooks`，以计数器为例：\\n\\n```ts\\n// src/models/counterModel.ts\\nimport { useState, useCallback } from 'react';\\n\\nexport default function Page() {\\n  const [counter, setCounter] = useState(0);\\n\\n  const increment = useCallback(() => setCounter((c) => c + 1), []);\\n  const decrement = useCallback(() => setCounter((c) => c - 1), []);\\n\\n  return { counter, increment, decrement };\\n};\\n```\\n\\n在项目实践中，我们通常需要请求后端接口，来获取所需的数据。现在让我们来扩展前面获取用户信息的例子：\\n\\n```ts\\n// src/models/userModel.ts\\nimport { useState } from 'react';\\nimport { getUser } from '@/services/user';\\n\\nexport default function Page() {\\n  const [user, setUser] = useState({});\\n  const [loading, setLoading] = useState(true);\\n\\n  useEffect(() => {\\n    getUser().then((res) => {\\n      setUser(res);\\n      setLoading(false);\\n    });\\n  }, []);\\n\\n  return {\\n    user,\\n    loading,\\n  };\\n};\\n```\\n\\n如果您在项目中使用了 [ahooks](https://ahooks.js.org)，可以像这样组织您的代码：\\n\\n```ts\\n// src/models/userModel.ts\\nimport { useRequest } from 'ahooks';\\nimport { getUser } from '@/services/user';\\n\\nexport default function Page() {\\n  const { data: user, loading: loading } = useRequest(async () => {\\n    const res = await getUser();\\n    if (res) {\\n      return res;\\n    }\\n    return {};\\n  });\\n\\n  return {\\n    user,\\n    loading,\\n  };\\n};\\n```\\n\\n### 使用 Model\\n\\n现在，您想要在某个组件中使用全局的 Model。以用户信息为例，只需要调用 `useModel` 这一钩子函数：\\n\\n```tsx\\n// src/components/Username/index.tsx\\nimport { useModel } from '@umijs/max';\\n\\nexport default function Page() {\\n  const { user, loading } = useModel('userModel');\\n\\n  return (\\n    {loading ? <></>: <div>{user.username}</div>}\\n  );\\n}\\n```\\n\\n其中，`useModel()` 方法传入的参数为 Model 的**命名空间**。\\n\\n## 性能优化\\n\\n`useModel()` 方法可以接受可选的第二个参数，当组件只需要使用 Model 中的部分参数，而对其它参数的变化不感兴趣时，可以传入一个函数进行过滤。以实现计数器的操作按钮为例：\\n\\n```tsx\\n// src/components/CounterActions/index.tsx\\nimport { useModel } from '@umijs/max';\\n\\nexport default function Page() {\\n  const { add, minus } = useModel('counterModel', (model) => ({\\n    add: model.increment,\\n    minus: model.decrement,\\n  }));\\n\\n  return (\\n    <div>\\n      <button onClick={add}>add by 1</button>\\n      <button onClick={minus}>minus by 1</button>\\n    </div>\\n  );\\n};\\n```\\n\\n上面的组件并不关心计数器 Model 中的 `counter` 值，只需要使用 Model 提供的 `increment()` 和 `decrement()` 方法。于是我们传入了一个函数作为 `useModel()` 方法的第二个参数，该函数的返回值将作为 `useModel()` 方法的返回值。\\n\\n这样，我们过滤掉了 `counter` 这一频繁变化的值，避免了组件重复渲染带来的性能损失。\\n\\n## API\\n\\n### `useModel`\\n\\n`useModel()` 是一个钩子函数，提供了使用 Model 的能力。它接受两个参数：\\n\\n| 参数 | 类型 | 介绍 |\\n| --- | --- | --- |\\n| `namespace` | `String` | Model 文件的命名空间 |\\n| `updater` | `(model: any) => any` | 可选参数。传入一个函数，函数的返回值为当前组件中需要使用到的 Model 状态或数据，并作为 `useModel()` 方法的返回值。对优化组件性能具有重要意义。 |\\n\\n```tsx\\n// src/components/AdminInfo/index.tsx\\nimport { useModel } from 'umi';\\n\\nexport default function Page() {\\n  const { user, fetchUser } = useModel('adminModel', (model) => ({\\n    user: model.admin,\\n    fetchUser: model.fetchAdmin,\\n  }));\\n\\n  return <>hello</>;\\n};\\n```\\n\\n## License\\n\\nLicensed under the MIT License.\"\n  }"],"names":["components","data","source"],"sourceRoot":""}