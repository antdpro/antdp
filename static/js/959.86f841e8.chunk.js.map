{"version":3,"file":"static/js/959.86f841e8.chunk.js","mappings":"iIACA,WACIA,WAAY,CAAG,EACfC,KAAM,CAAC,EACPC,OAAQ,8h9B","sources":["pages/develop/request/README.md"],"sourcesContent":["\nexport default {\n    components: {  },\n    data: {},\n    source: \"# 请求\\n简介\\n对于中后台应用来说，很大一部分工作就在于请求后端的 CRUD 的接口，为进一步降低用户对请求层的感知，我们移除了默认生成的 utils/request.ts 文件，改成通过配置化的方式暴露给开发者做请求的配置和增强处理；同时通过业务总结出一套标准的接口结构规范，并提供统一的接口解析、错误处理的能力；后续将持续完善可配置项、提供垂直场景如列表、登录失效等解决方案。\\n## request\\n\\n我们基于umi-request进行了二次封装了@antp/request，参见[umi-request](https://github.com/umijs/umi-request)\\n\\n### 参数\\n\\n| 参数    | 说明     | 类型           | 默认值 |\\n| :------ | :------- | :------------- | :----- |\\n| url | 请求地址 | string        | -      |\\n\\n### Options\\n| 参数    | 说明     | 类型           | 默认值 |\\n| :------ | :------- | :------------- | :----- |\\n| method | 请求方法 | `POST \\\\| GET`    | -      |\\n| data | 请求传递给后端的参数 | any      | -      |\\n\\n### 使用方法\\n```js\\nimport request from '@antdp/request';\\nrequest('/api/user', {method:'POST' ,data: { name : 1 }})\\n```\\n\\n### 页面中调用接口\\n#### 配合dva调用接口\\n> 在servers/index.js中\\n```ts\\nimport { request } from \\\"@uiw-admin/utils\\\"\\n\\nexport const selectById  = (params) => request(\\\"/api/selectById\\\",{ method:\\\"POST\\\",data: { ...params } })\\n\\n```\\n> 在model/index.js中\\n```js\\nimport { selectById } from '../servers';\\n\\nexport default {\\n  namespace:'index',\\n  state:{\\n    name:'',\\n  },\\n  reducers:{\\n    updateState: (state, payload) => ({\\n      ...state,\\n      ...payload,\\n    }),\\n  },\\n  effects:{\\n    selectById({ paylog },{ call,put }){\\n      const data = yield call(selectById, payload);\\n      if(data.code === 1){\\n        yield put({\\n          type: 'updateData',\\n          paylog:{\\n            name:data.data\\n          }\\n        })\\n      }\\n    }\\n  }\\n}\\n\\n```\\n\\n> 在页面中调用\\n```jsx\\nimport React from 'react';\\nimport { useDispatch, useSelector } from 'dva';\\n\\nexport default const Index = () => {\\n  const dispatch = useDispatch()\\n  const { name } = useSelector(state => state.index) || {}\\n  React.useEffect(()=>{\\n     dispatch({\\n      type: 'index/selectById',\\n      payload:{ id:1 },\\n    })\\n  },[])\\n  return <div>{name}</div>\\n}\\n```\\n\\n## umi内置 request 和 useRequest\\n在项目config/config中添加如下 \\n```diff\\nexport default {\\n+  request: {\\n+    dataField: 'data'\\n+  },\\n};\\n```\\n构建时配置可以为 useRequest 配置 dataField ，该配置的默认值是 data。该配置的主要目的是方便 useRequest 直接消费数据。如果你想要在消费数据时拿到后端的原始数据，需要在这里配置 dataField 为 '' 。\\n\\n比如你的后端返回的数据格式如下。\\n\\n```js\\n{\\n  success: true,\\n  data: 123,\\n  code: 1,\\n}\\n```\\n\\n那么 `useRequest` 就可以直接消费 `data`。其值为 123，而不是 `{ success, data, code }`\\n\\n### 使用方法\\n\\n通过 `import { request,useRequest } from '@umijs/max'` 或 `import { request } from '@@/plugin-request'`  你可以使用umi内置的请求方法。\\n\\n`request` 接收的 `options`除了透传 [axios](https://axios-http.com/docs/req_config) 的所有 config 之外，umi还额外添加了几个属性 `skipErrorHandler`，`getResponse`，`requestInterceptors` 和 `responseInterceptors` 。\\n\\n示例如下：\\n\\n```js\\nrequest('/api/user', {\\n  params: { name : 1 },\\n  timeout: 2000,\\n  // other axios options\\n  skipErrorHandler: true,\\n  getResponse: false,\\n  requestInterceptors: [],\\n  responseInterceptors: [],\\n}\\n```\\n\\n当你的某个请求想要跳过错误处理时，可以通过将`skipErrorHandler`设为 `true` 来实现\\n\\nrequest 默认返回的是你后端的数据，如果你想要拿到 axios 完整的 response 结构，可以通过传入 `{ getResponse: true }` 来实现。\\n\\n`requestInterceptors` 和 `responseInterceptors` 的写法同运行时配置中的拦截器写法相同，它们为 request 注册拦截器。区别在于这里注册的拦截器是 \\\"一次性\\\" 的。另外，这里写的拦截器会在运行时配置中的拦截器之后被注册。**\\n\\n<strong>注意： 当你使用了 errorHandler 时，在这里注册的 response 拦截器会失效，因为在 errorHandler 就会 throw error</strong>\\n\\n### 页面中调用接口\\n\\n#### ✨配和useRequest调用接口\\n```jsx\\nimport React from 'react'\\nimport { request,useRequest } from '@umijs/max';\\n\\nconst Index = () => {\\n  const selectById  = (params) => request(\\\"/api/selectById\\\",{ method:\\\"POST\\\",data: { ...params } })\\n  const [ name ,setName ] = React.useState('')\\n  const { run, loading } = useRequest(selectById,\\n    manual: true,\\n    onSuccess: (req) => {\\n      setName(req);\\n    },\\n  )\\n\\n  React.useEffect(()=>run( id:1 ),[])\\n\\n  return <div>{name}</div>\\n}\\nexport default Index\\n```\\n\\n## react-query\\n我们基于react-query进行了二次封装了`useReactQuery` 和 `useReactMutation`，参见[react-query](https://tanstack.com/query/latest)（和 @tanstack/react-query 是同一个）\\n\\n### 启用方式\\n由于umi已内置`react-query`,你只需在`congfig/config`中配置\\n\\n```js\\nreactQuery: {\\n  // devtool: boolean，是否开启 react query 官方 devtool 工具，默认 false\\n  devtool: false,\\n  // queryClient: boolean, 是否注册全局的 QueryClient 和 QueryClientProvier，默认 true\\n  queryClient: false,\\n},\\n```\\n\\n### API 请求 hooks\\n\\n下面是 API 请求示例，如 GET/POST 请求示例\\n\\n#### useReactQuery\\n\\n主要用于**默认**触发请求数据，默认 `GET` 请求，变更使用 `method=\\\"POST\\\"` 参数配置\\n\\n```jsx\\nuseReactQuery({ \\n  queryKey: ['user', userId], \\n  url: `/api/user/list?id=${userId}`\\n});\\n```\\n<!--rehype:style=background:#00de2247;border: 0;-->\\n\\n👆👆👆👆 上面是**推荐**使用 👆👆👆👆👆\\n\\n```jsx\\nimport { fetchFn, useReactQuery } from '@antdp/hooks';\\n\\nuseReactQuery({ queryKey: ['user'], url: '/api/user/list' });\\nuseReactQuery({ queryKey: ['user'], url: '/api/user/list', method: 'POST' });\\nuseReactQuery({ queryKey: ['user', userId], queryFn: () => fetchFn(`/api/user/list?id=${userId}`) });\\nuseReactQuery({\\n  queryKey: ['user', userId],\\n  queryFn: async () => {\\n    return fetchFn(`/api/user/list?id=${userId}`);\\n  },\\n});\\nuseReactQuery({\\n  queryKey: ['user', userId],\\n  queryFn: ({ queryKey }) => fetchFn(`/api/user/list?id=${queryKey[1]}`);,\\n});\\nuseReactQuery({\\n  queryKey: ['user'],\\n  url: '/api/user/list',\\n  initialData: [....],\\n});\\n\\nconst { isInitialLoading, isError, data, error, refetch, isFetching } = useQuery(...)\\n```\\n\\n示例\\n\\n```javascript\\nimport { useReactQuery } from '@antdp/hooks';\\n\\nexport default function HomePage() {\\n  const { isLoading, isError, data } = useReactQuery({\\n    url: `/api/user/list`,\\n    queryKey: ['user-list'],\\n  });\\n\\n  return (\\n    <div>\\n      <p className=\\\"title\\\">x react-query</p>\\n      {isError && <p>请求 API 错误 ...</p>}\\n      {isLoading && <p>Loading ...</p>}\\n      {data && <p>现在有 {data.stargazers_count} 颗星！</p>}\\n    </div>\\n  );\\n}\\n```\\n\\n##### Query 选项\\n\\n```js\\nconst { data } = useReactQuery({\\n  /** 设置 Content-Type，默认值 `json`，'Content-Type' = 'application/json' */\\n  contentType: \\\"json\\\" | 'form';\\n  // 请求 API\\n  url: '/api/user/list'\\n  // 用于此查询的查询键。查询键将被 hash 成一个稳定的 hash 。当此键更改时，查询将自动更新（只要 enabled 未设置为 false）\\n  queryKey: ['user-list', userId],\\n  // 只要查询成功获取新数据，此函数就会触发。\\n  onSuccess: (data: TData) => void\\n  // 如果查询遇到错误并将传递错误，则此函数将触发。\\n  onError: (error: TError) => void\\n  // 每当成功获取查询或出错并传递数据或错误时，此函数都会触发。\\n  onSettled: (data?: TData, error?: TError) => void\\n  // 此选项可用于转换或选择查询函数返回的部分数据。 它会影响返回的数据值，但不会影响存储在查询缓存中的内容。\\n  select: (data: TData) => unknown\\n  select: (dt) => {\\n    // 改变请求到的 data 数据，返回部分 data 数据\\n    return dt\\n  },\\n  // 将此设置为 true 以启用暂停模式。\\n  // 当 true 时，useQuery 将在 status === 'loading' 时暂停\\n  // 当 true 时，useQuery 将在 status === 'error' 时抛出运行时错误\\n  suspense: true,\\n  // 将此设置为 false 以禁止此查询自动运行。https://tanstack.com/query/v4/docs/react/guides/dependent-queries\\n  // 在 userId 存在之前，查询不会执行\\n  enabled: !!userId,\\n  // 如果为 false，失败的查询默认不会重试。如果为真，失败的查询将无限重试\\n  // 如果设置为数字，例如 3、失败的查询会重试，直到失败的查询计数满足那个数\\n  retry: boolean | number | (failureCount: number, error: TError) => boolean\\n  // 默认值为 'online'，请参阅网络模式：https://tanstack.com/query/v4/docs/react/guides/network-mode\\n  networkMode: 'online' | 'always' | 'offlineFirst'\\n  // 如果设置为 false，如果查询包含错误，则不会在挂载时重试。默认为真\\n  retryOnMount: boolean\\n  // 此函数接收一个 retryAttempt 整数和实际错误，并返回在下一次尝试之前应用的延迟（以毫秒为单位）\\n  // 像 attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000) 这样的函数应用指数退避\\n  // 像 attempt => attempt * 1000 这样的函数应用线性退避。\\n  retryDelay: number | (retryAttempt: number, error: TError) => number\\n  // 默认值为 0，数据被认为过时后的时间（以毫秒为单位）。该值仅适用于定义它的挂钩\\n  // 如果设置为“Infinity”，数据将永远不会被认为是陈旧的\\n  staleTime: number | Infinity\\n  // 在 SSR 期间默认为 5 * 60 * 1000（5 分钟）或无限\\n  // 未使用(unused)/非活动(inactive)缓存数据保留在内存中的时间（以毫秒为单位）。当查询的缓存变为未使用或不活动时，该缓存数据将在这段时间后被垃圾收集。 当指定不同的缓存时间时，将使用最长的一个\\n  // 如果设置为 Infinity，将禁用垃圾收集\\n  cacheTime: number | Infinity\\n  // 如果设置为一个数字，所有查询将以毫秒为单位以该频率连续重新获取\\n  // 如果设置为一个函数，该函数将使用最新的数据执行并查询以计算频率\\n  refetchInterval: number | false | ((data: TData | undefined, query: Query) => number | false)\\n  // 如果设置为 true，则设置为使用 refetchInterval 连续重新获取的查询将在其选项卡/窗口处于后台时继续重新获取\\n  refetchIntervalInBackground: boolean\\n  // 默认为 true\\n  // 如果设置为 true，如果数据过时，查询将在挂载时重新获取\\n  // 如果设置为 false，查询将不会在挂载时重新获取\\n  // 如果设置为 always，查询将始终在挂载时重新获取\\n  // 如果设置为一个函数，该函数将与查询一起执行以计算值\\n  refetchOnMount: boolean | \\\"always\\\" | ((query: Query) => boolean | \\\"always\\\")\\n  // 默认为 true\\n  // 如果设置为 true，如果数据陈旧，查询将重新获取窗口焦点\\n  // 如果设置为 false，查询将不会重新获取窗口焦点\\n  // 如果设置为 always，查询将始终重新获取窗口焦点\\n  // 如果设置为一个函数，该函数将与查询一起执行以计算值\\n  refetchOnWindowFocus: boolean | \\\"always\\\" | ((query: Query) => boolean | \\\"always\\\")\\n  // 默认为 true\\n  // 如果设置为 true，如果数据过时，查询将在重新连接时重新获取\\n  // 如果设置为 false，查询将不会在重新连接时重新获取\\n  // 如果设置为 always，查询将始终重新获取窗口焦点\\n  // 如果设置为一个函数，该函数将与查询一起执行以计算值\\n  refetchOnReconnect: boolean | \\\"always\\\" | ((query: Query) => boolean | \\\"always\\\")\\n  // 如果设置，组件将仅在任何列出的属性更改时重新渲染\\n  // 例如，如果设置为 ['data', 'error']，组件将仅在数据或错误属性更改时重新呈现\\n  // 如果设置为“all”，组件将选择退出智能跟踪并在更新查询时重新呈现\\n  // 默认情况下，将跟踪对属性的访问，并且仅当跟踪的属性之一发生更改时，组件才会重新呈现\\n  notifyOnChangeProps: string[] | \\\"all\\\"\\n  // 如果设置，此值将用作查询缓存的初始数据（只要尚未创建或缓存查询）\\n  // 如果设置为一个函数，该函数将在共享/根查询初始化期间被调用一次，并期望同步返回 initialData\\n  // 默认情况下，初始数据被认为是陈旧的，除非设置了 staleTime。\\n  // initialData 被持久化到缓存\\n  initialData: TData | () => TData\\n  // 如果设置，该值将用作上次更新 initialData 本身的时间（以毫秒为单位）。\\n  initialDataUpdatedAt: number | (() => number | undefined)\\n  // 如果设置，当查询仍在加载数据中且未提供 initialData 时，此值将用作此特定查询观察器的占位符数据。\\n  // `placeholderData` 不会持久化到缓存\\n  placeholderData: TData | () => TData\\n  // 默认为 false 如果设置，则在获取新数据时将保留任何以前的数据，因为查询键已更改。\\n  keepPreviousData: boolean\\n  // 默认为 true 如果设置为 false，将禁用查询结果之间的结构共享\\n  // 如果设置为一个函数，旧数据值和新数据值将通过该函数传递，该函数应将它们组合成解析数据以供查询。 这样，您可以保留旧数据的引用以提高性能，即使该数据包含不可序列化的值也是如此\\n  structuralSharing: boolean | ((oldData: TData | undefined, newData: TData) => TData)\\n  // 默认为全局查询配置的 useErrorBoundary 值，未定义\\n  // 如果您希望在渲染阶段抛出错误并传播到最近的错误边界，请将此设置为 true\\n  // 将此设置为 false 以禁用 suspense 将错误抛出到错误边界的默认行为\\n  // 如果设置为函数，它将传递错误和查询，它应该返回一个布尔值，指示是在错误边界中显示错误 (true) 还是将错误作为状态返回 (false)\\n  useErrorBoundary: undefined | boolean | (error: TError, query: Query) => boolean\\n  // 如果设置，则存储有关查询缓存条目的附加信息，可根据需要使用。 只要查询可用，它就可以访问，它也是提供给 queryFn 的 QueryFunctionContext 的一部分\\n  meta: Record<string, unknown>\\n  // 使用它来使用自定义 React 查询上下文。 否则，将使用 defaultContext\\n  context: React.Context<QueryClient | undefined>\\n});\\n```\\n\\n##### Fetch 选项\\n\\n请求 `fetch` 相关参数 \\n\\n```js\\nconst { data } = useReactQuery({\\n  /** 用于设置请求正文的 BodyInit 对象或 null。*/\\n  body?: BodyInit | null;\\n  /** 一个字符串，指示请求将如何与浏览器的缓存交互以设置请求的缓存。*/\\n  cache?: RequestCache;\\n  /** 一个字符串，指示凭据是始终、从不还是仅在发送到同源 URL 时随请求一起发送。 设置请求的凭据。*/\\n  credentials?: RequestCredentials;\\n  /** Headers 对象、对象字面量或包含两项的数组，用于设置请求的标头。*/\\n  headers?: HeadersInit;\\n  /** 要按请求获取的资源的加密哈希。 设置请求的完整性。*/\\n  integrity?: string;\\n  /** 设置请求的保活的布尔值。*/\\n  keepalive?: boolean;\\n  /** 设置请求方法的字符串。(GET|POST|PUT....)*/\\n  method?: string;\\n  /** 一个字符串，指示请求是使用 CORS，还是仅限于同源 URL。 设置请求的模式。*/\\n  mode?: RequestMode;\\n  /** 一个字符串，指示请求是否遵循重定向、在遇到重定向时导致错误或返回重定向（以不透明的方式）。 放s request's redirect. */\\n  redirect?: RequestRedirect;\\n  /** 一个字符串，其值为同源 URL、“about:client”或空字符串，用于设置请求的引荐来源网址。*/\\n  referrer?: string;\\n  /** 设置请求的 referrerPolicy 的引用策略。*/\\n  referrerPolicy?: ReferrerPolicy;\\n  /** 用于设置请求信号的 AbortSignal。*/\\n  signal?: AbortSignal | null;\\n  /** 只能为空。 用于解除来自任何窗口的请求。*/\\n  window?: null;\\n});\\n```\\n\\n#### useReactMutation\\n\\n用于触发的 `API` 请求\\n\\n```jsx\\nuseReactMutation({\\n  mutationKey: ['user', dataForm],\\n  url: '/api/login'\\n});\\n```\\n<!--rehype:style=background:#00de2247;border: 0;-->\\n\\n👆👆👆👆 上面是**推荐**使用，**dataForm** 用于给 `body` 传递的 *json* 数据 👆👆👆👆👆\\n\\n```javascript\\nimport { fetchFn, useReactMutation } from '@antdp/hooks';\\n\\nuseReactMutation({ mutationKey: ['user'], url: '/api/login' });\\nuseReactMutation({ mutationKey: ['user'], url: '/api/login', method: 'PUT' });\\nuseReactMutation({ mutationKey: ['user', dataForm], url: '/api/login' });\\nuseReactMutation({\\n  mutationKey: ['user', dataForm], \\n  mutationFn: () => fetchFn(`/api/login?id=${dataForm.userId}`, { method: 'PUT' })\\n});\\nuseReactMutation({\\n  mutationKey: ['user', dataForm],\\n  mutationFn: () => fetchFn('/api/login', { method: 'POST', body: JSON.stringify(dataForm) }),\\n});\\nuseReactMutation({\\n  mutationKey: ['user', dataForm],\\n  mutationFn: async () => {\\n    return fetchFn(`/api/login?id=${dataForm.username}`, { method: 'DELETE', body: JSON.stringify(dataForm) });\\n  },\\n});\\nuseReactMutation({\\n  mutationKey: ['user', dataForm],\\n  mutationFn: (data) => {\\n    return fetchFn(`/api/login`, { method: 'POST', body: JSON.stringify(data) })\\n  },\\n});\\n```\\n\\n**登录页面**示例\\n\\n```javascript\\nimport UserLogin from '@antdp/user-login';\\nimport { useReactMutation } from '@antdp/hooks';\\n\\nconst UserLayout = (props) => {\\n  const mutation = useReactMutation({ url: '/api/users/login' });\\n  return (\\n      <UserLogin\\n        projectName=\\\"Antdp\\\"\\n        onFinish={async (values) => {\\n          const { code, token, data } = await mutation.mutateAsync(values);\\n          // 请求成功后操作\\n        }}\\n        type=\\\"account\\\"\\n        loading={mutation.loading}\\n        formBtns={[\\n          {\\n            label: '登录',\\n            attr: {\\n              type: 'primary',\\n              htmlType: 'submit',\\n              style: {\\n                marginRight: 20,\\n              },\\n            },\\n          },\\n          {\\n            label: '重置',\\n            attr: {\\n              type: 'primary',\\n            },\\n          },\\n        ]}\\n      >\\n      </UserLogin>\\n  );\\n};\\n\\nexport default UserLayout;\\n\\n```\\n\\n在任何给定时刻，`mutation` 只能处于以下状态之一：\\n\\n- `isIdle` or `status === 'idle'` - mutation 当前处于空闲状态或处于新鲜/重置状态\\n- `isLoading` or `status === 'loading'` - mutation 当前正在运行\\n- `isError` or `status === 'error'` - mutation 遇到错误\\n- `isSuccess` or `status === 'success'` - mutation 成功并且 mutation 数据可用\\n\\n除了这些主要状态之外，还可以根据 `mutation` 状态获得更多信息：\\n\\n- `error` - 如果 mutation 处于错误状态，则可以通过 error 属性获得错误。\\n- `data` - 如果 mutation 处于成功状态，则数据可通过 data 属性获得。\\n\\n```javascript\\nconst mutation = useReactMutation({\\n  url: '/api/login',\\n  mutationKey: ['user-login', data],\\n  method: 'PUT'\\n});\\n```\\n\\n##### 副作用 mutation 选项\\n\\n```js\\nconst mutation = useReactMutation({\\n  url: '/api/login',\\n  onMutate: (variables) => {\\n    // mutation 即将发生！\\n    \\n    // 可选地返回包含数据的上下文，例如在回滚时使用\\n    return { id: 1 }\\n  },\\n  onError: (error, variables, context) => {\\n    // 发生错误！\\n    console.log(`rolling back optimistic update with id ${context.id}`)\\n  },\\n  onSuccess: (data, variables, context) => {\\n    // Boom baby!\\n  },\\n  onSettled: (data, error, variables, context) => {\\n    // 错误或成功......没关系！\\n  },\\n})\\n```\\n\\n您可能会发现，在调用 `mutate` 时，您想要触发除 `useReactMutation` 上定义的回调之外的其他回调。 这可用于触发组件特定的副作用。 为此，您可以在 `mutate` 变量之后向 `mutate` 函数提供任何相同的回调选项。 支持的选项包括：`onSuccess`、`onError` 和 `onSettled`。 请记住，如果您的组件在变更完成之前卸载，那么这些额外的回调将不会运行。\\n\\n```js\\nmutation.mutate(todo, {\\n  onSuccess: (data, variables, context) => {\\n    // I will fire second!\\n  },\\n  onError: (error, variables, context) => {\\n    // I will fire second!\\n  },\\n  onSettled: (data, error, variables, context) => {\\n    // I will fire second!\\n  },\\n})\\n```\\n\\n### Query Keys\\n\\nTanStack Query 的核心是基于查询键为您管理查询缓存。查询键必须是顶层的数组，并且可以像具有单个字符串的数组一样简单，也可以像包含许多字符串和嵌套对象的数组一样复杂。 只要查询键是可序列化的，并且对于查询数据是唯一的，就可以使用它！\\n\\n```js\\nuseReactQuery({\\n  url: `https://api.example.com/users?status=${status}&page=${page}`,\\n  queryKey: ['use-list', { status, page }],\\n});\\n```\\n\\n### 请求重试\\n\\n```js\\nconst { isLoading, isError, data } = useReactQuery({\\n  url: `/api/user/list?id=${userId}`,\\n  queryKey: ['user-list', userId],\\n  retry: 10, // 在显示错误之前将重试失败的请求 10 次\\n});\\n```\\n\\n\\n\\n## License\\n\\nLicensed under the MIT License.\"\n  }"],"names":["components","data","source"],"sourceRoot":""}